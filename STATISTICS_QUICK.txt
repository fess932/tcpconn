╔═══════════════════════════════════════════════════════════════╗
║     Статистика передачи данных - Быстрая справка            ║
╚═══════════════════════════════════════════════════════════════╝

📊 СОЗДАНИЕ И ИСПОЛЬЗОВАНИЕ
─────────────────────────────────────────────────────────────────
stats := tcpconn.NewStatistics()

// Записать события
stats.RecordPacketSent(1024)       // отправлен пакет 1KB
stats.RecordPacketReceived(2048)   // получен пакет 2KB
stats.RecordPacketLost()           // пакет потерян
stats.RecordLatency(150)           // задержка 150μs

// Получить данные
sent := stats.GetPacketsSent()     // количество отправленных
loss := stats.GetPacketLossRate()  // процент потерь
rate := stats.GetSendRate()        // скорость отправки (байт/с)

📈 СНИМОК СТАТИСТИКИ
─────────────────────────────────────────────────────────────────
snapshot := stats.GetSnapshot()

fmt.Printf("Отправлено: %d пакетов (%s)\n",
    snapshot.PacketsSent,
    tcpconn.FormatBytes(snapshot.BytesSent))

fmt.Printf("Скорость: %s\n",
    tcpconn.FormatRate(snapshot.SendRateBytesPerSec))

fmt.Printf("Потери: %.2f%%\n", snapshot.PacketLossRate)

🔄 ИНТЕГРАЦИЯ С TCPCONNECTION
─────────────────────────────────────────────────────────────────
conn, _ := tcpconn.NewTCPConnection(4096)
conn.Connect()

// Статистика собирается автоматически
conn.Write([]byte("Hello"))

// Получение статистики (только через snapshot!)
snapshot := conn.GetStatisticsSnapshot()

// Сброс статистики
conn.ResetStatistics()

// Если нужен прямой доступ - используйте внешний объект:
stats := tcpconn.NewStatistics()
conn, _ := tcpconn.NewTCPConnectionWithStats(4096, stats)
// Теперь можно использовать stats напрямую

📋 ДОСТУПНЫЕ МЕТРИКИ
─────────────────────────────────────────────────────────────────
Пакеты:
  ✓ PacketsSent          - отправлено пакетов
  ✓ PacketsReceived      - получено пакетов
  ✓ PacketsLost          - потеряно пакетов
  ✓ PacketsRetried       - повторных отправок

Байты:
  ✓ BytesSent            - отправлено байт
  ✓ BytesReceived        - получено байт

Скорость:
  ✓ SendRateBytesPerSec  - скорость отправки (байт/с)
  ✓ RecvRateBytesPerSec  - скорость приёма (байт/с)
  ✓ SendRatePacketsPerSec - скорость отправки (пакет/с)
  ✓ RecvRatePacketsPerSec - скорость приёма (пакет/с)

Задержки (микросекунды):
  ✓ MinLatencyUs         - минимальная
  ✓ AvgLatencyUs         - средняя
  ✓ MaxLatencyUs         - максимальная

Ошибки:
  ✓ Errors               - количество ошибок
  ✓ Timeouts             - количество таймаутов
  ✓ Resets               - количество сбросов

Производные:
  ✓ PacketLossRate       - процент потерь (0-100)
  ✓ Uptime               - время работы
  ✓ TimeSinceReset       - время с последнего сброса

⚡ ПРОИЗВОДИТЕЛЬНОСТЬ (Apple M2)
─────────────────────────────────────────────────────────────────
RecordPacketSent:       ~278 ns/op  (79 B/op, 0 allocs)
RecordPacketReceived:   ~271 ns/op  (79 B/op, 0 allocs)
RecordLatency:          ~8.7 ns/op  (0 B/op, 0 allocs)
GetSnapshot:            ~138 ns/op  (0 B/op, 0 allocs)
ConcurrentReads:        ~84  ns/op  (0 B/op, 0 allocs)

🛡️ ПОТОКОБЕЗОПАСНОСТЬ
─────────────────────────────────────────────────────────────────
✓ Все операции атомарны или защищены мьютексом
✓ Безопасно использовать из множества горутин
✓ Lock-free чтение для большинства операций

💡 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
─────────────────────────────────────────────────────────────────

1. Мониторинг в реальном времени:
   ──────────────────────────────────────────────────────────
   ticker := time.NewTicker(5 * time.Second)
   for range ticker.C {
       snap := stats.GetSnapshot()
       fmt.Printf("Отправлено: %s (%s)\n",
           tcpconn.FormatBytes(snap.BytesSent),
           tcpconn.FormatRate(snap.SendRateBytesPerSec))
   }

2. Измерение RTT (с внешним объектом):
   ──────────────────────────────────────────────────────────
   rttStats := tcpconn.NewStatistics()
   start := time.Now()
   // ... отправка запроса и получение ответа ...
   rtt := time.Since(start).Microseconds()
   rttStats.RecordLatency(uint64(rtt))

3. Обнаружение потерь:
   ──────────────────────────────────────────────────────────
   if stats.GetPacketLossRate() > 5.0 {
       log.Printf("⚠️  Высокие потери: %.2f%%",
           stats.GetPacketLossRate())
   }

4. Оповещения:
   ──────────────────────────────────────────────────────────
   snap := stats.GetSnapshot()

   if snap.PacketLossRate > 10.0 {
       alert("Критические потери пакетов")
   }

   if snap.MaxLatencyUs > 1000 {
       alert("Высокая задержка")
   }

🔧 УТИЛИТЫ
─────────────────────────────────────────────────────────────────
tcpconn.FormatBytes(1024)          // "1.00 KiB"
tcpconn.FormatBytes(1024*1024)     // "1.00 MiB"
tcpconn.FormatRate(1024*1024)      // "1.00 MiB/s"

snapshot.String()                  // полный отчёт

⚠️  ВАЖНО: ПОТОКОБЕЗОПАСНОСТЬ
─────────────────────────────────────────────────────────────
❌ НЕ используйте GetStatistics() - метод удалён!
✅ Используйте GetStatisticsSnapshot() - возвращает копию
✅ Или создайте внешний объект через NewTCPConnectionWithStats()

Почему? GetStatistics() возвращал указатель, что обходило защиту
от конкурентного доступа и могло привести к race conditions.

📚 ДОКУМЕНТАЦИЯ
─────────────────────────────────────────────────────────────
Полная документация:     STATISTICS.md
Примеры кода:            statistics_examples_test.go
Тесты:                   statistics_test.go
Основная документация:   README.md

✅ ГОТОВО К ИСПОЛЬЗОВАНИЮ
─────────────────────────────────────────────────────────────────
Версия: 1.1.0
Покрытие тестами: 89.0%
Потокобезопасно: Да
Производительность: Высокая

Начните с: go test -v -run ExampleStatistics
